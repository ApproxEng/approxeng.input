

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Advanced Usage Guide &mdash; Approximate Engineering - Input 2.3.0 documentation</title>
  

  
  
  
  

  

  
  
    
      <link rel="search" type="application/opensearchdescription+xml"
            title="Search within Approximate Engineering - Input 2.3.0 documentation"
            href="_static/opensearch.xml"/>
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="LEDs and Battery Monitoring" href="sys.html" />
    <link rel="prev" title="Tiny4WD Robot Drive" href="examples/tiny4wd.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Approximate Engineering - Input
          

          
          </a>

          
            
            
              <div class="version">
                2.3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="simpleusage.html">Simple Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="simpleusage.html#standard-names">Standard Names</a></li>
<li class="toctree-l1"><a class="reference internal" href="bluetooth.html">Pairing Controllers over Bluetooth</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="addingcontrollers.html">Adding support for a new controller type</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Advanced Usage Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#constructing-and-binding-a-controller">Constructing and Binding a Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="#handling-buttons">Handling Buttons</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#handling-button-presses-as-events">Handling Button Presses as Events</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#more-about-analogue-axes">More about Analogue Axes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sys.html">LEDs and Battery Monitoring</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Approximate Engineering - Input</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Advanced Usage Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="advanced-usage-guide">
<h1>Advanced Usage Guide<a class="headerlink" href="#advanced-usage-guide" title="Permalink to this headline">¶</a></h1>
<p>This module contains general support for game controllers. It includes the top level classes such as buttons and
joystick axes which are used for any kind of controller, particular controllers and binding mechanisms are implemented
in sub-modules. The key classes shared across all controllers are:</p>
<ul class="simple">
<li><a class="reference internal" href="api/input.html#approxeng.input.CentredAxis" title="approxeng.input.CentredAxis"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.CentredAxis</span></code></a> <a class="reference internal" href="api/input.html#approxeng.input.TriggerAxis" title="approxeng.input.TriggerAxis"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.TriggerAxis</span></code></a> and <a class="reference internal" href="api/input.html#approxeng.input.BinaryAxis" title="approxeng.input.BinaryAxis"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.BinaryAxis</span></code></a>
represent different kinds of axis of an analogue control. The centred axis is used for joysticks with a negative value
at one end of the range and positive at the other, whereas the trigger axis is used for axes with zero at the resting
position and increasingly positive values as the control is pressed. As the names suggest, these are used for centred
and trigger controls respectively - a PS3 joystick consists of two centred axes, an XBox One front trigger consists of
a single trigger axis. The BinaryAxis is used for controllers which export buttons as axes (both the PS4 and the XBox
controller D-pads are actually a pair of axes in terms of implementation, although they don’t have any analogue
control, they just emit either -1, 0 or 1)</li>
<li><a class="reference internal" href="api/input.html#approxeng.input.Button" title="approxeng.input.Button"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.Button</span></code></a> represents a single button. As with the Axis class you don’t create these, instead you
need to use the instances provided by the driver classes.</li>
<li><a class="reference internal" href="api/input.html#approxeng.input.Buttons" title="approxeng.input.Buttons"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.Buttons</span></code></a> represents the state of all the buttons on the controller. You’ll use the provided
instance of this class to register button handlers, ask whether any buttons were pressed, and get information about
how long a button has been held down.</li>
<li>Finally, all controller classes inherit from <a class="reference internal" href="api/input.html#approxeng.input.Controller" title="approxeng.input.Controller"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.Controller</span></code></a>. This provides a
<a class="reference internal" href="api/input.html#approxeng.input.Buttons" title="approxeng.input.Buttons"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.Buttons</span></code></a> instance called ‘buttons’, and an <a class="reference internal" href="api/input.html#approxeng.input.Axes" title="approxeng.input.Axes"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.Axes</span></code></a> instance called
‘axes’. These will come in handy later!</li>
</ul>
<div class="section" id="constructing-and-binding-a-controller">
<h2>Constructing and Binding a Controller<a class="headerlink" href="#constructing-and-binding-a-controller" title="Permalink to this headline">¶</a></h2>
<p>Once your controller is physically connected to the computer (whether by USB, bluetooth, or magic) and you have a
corresponding entry in the dev filesystem, you need to create an object to receive and interpret events from the
hardware, and you need to set up a mechanism by which events will be sent to that object. The object in this case will
be a subclass of <a class="reference internal" href="api/input.html#approxeng.input.Controller" title="approxeng.input.Controller"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.Controller</span></code></a>, currently the following controllers are supported:</p>
<ul class="simple">
<li><a class="reference internal" href="api/dualshock3.html#approxeng.input.dualshock3.DualShock3" title="approxeng.input.dualshock3.DualShock3"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.dualshock3.DualShock3</span></code></a> handles PS3 controllers</li>
<li><a class="reference internal" href="api/dualshock4.html#approxeng.input.dualshock4.DualShock4" title="approxeng.input.dualshock4.DualShock4"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.dualshock4.DualShock4</span></code></a> is for PS4 controllers</li>
<li><a class="reference internal" href="api/xboxone.html#approxeng.input.xboxone.WiredXBoxOneSPad" title="approxeng.input.xboxone.WiredXBoxOneSPad"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.xboxone.WiredXBoxOneSPad</span></code></a> and <a class="reference internal" href="api/xboxone.html#approxeng.input.xboxone.WirelessXBoxOneSPad" title="approxeng.input.xboxone.WirelessXBoxOneSPad"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.xboxone.WirelessXBoxOneSPad</span></code></a> are for the
newer XBox One controllers. For whatever reason this controller reports different axes and buttons when connected over
bluetooth to when it’s connected with a wire, so you’ll need to use the correct one!</li>
<li><a class="reference internal" href="api/rockcandy.html#approxeng.input.rockcandy.RockCandy" title="approxeng.input.rockcandy.RockCandy"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.rockcandy.RockCandy</span></code></a> for the Rock Candy PS4 controller clone (it appears to describe itself as
a PS3 controller, but has the controls of a PS4 one!)</li>
<li><a class="reference internal" href="api/steamcontroller.html#approxeng.input.steamcontroller.SteamController" title="approxeng.input.steamcontroller.SteamController"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.steamcontroller.SteamController</span></code></a> for the Valve Steam controller. This is a bit of a strange
one, and you’ll need to be running a driver which creates a virtual XBox360 device to use it, but it does work. See
<a class="reference internal" href="api/steamcontroller.html#api-steamcontroller"><span class="std std-ref">Steam Controller Support</span></a> for details.</li>
<li><a class="reference internal" href="api/wii.html#approxeng.input.wii.WiiRemotePro" title="approxeng.input.wii.WiiRemotePro"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.wii.WiiRemotePro</span></code></a> for the Nintendo Wii Remote Pro. If you’re running in a graphical
environment you’ll probably want to disable the default behaviour where the left stick controls the mouse - see
<a class="reference internal" href="api/wii.html#wii-remote-pro-label"><span class="std std-ref">Disabling ‘Stick as Mouse’ functionality</span></a> for instructions.</li>
<li><a class="reference internal" href="api/wiimote.html#approxeng.input.wiimote.WiiMote" title="approxeng.input.wiimote.WiiMote"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.wiimote.WiiMote</span></code></a> for <a class="reference internal" href="api/wiimote.html#api-wiimote"><span class="std std-ref">WiiMote Controller Support</span></a>.</li>
<li><a class="reference internal" href="api/sf30pro.html#approxeng.input.sf30pro.SF30Pro" title="approxeng.input.sf30pro.SF30Pro"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.sf30pro.SF30Pro</span></code></a> for <a class="reference internal" href="api/sf30pro.html#api-sf30pro"><span class="std std-ref">8Bitdo SF30Pro/SN30Pro Controller Support</span></a>.</li>
<li><a class="reference internal" href="api/pihut.html#approxeng.input.pihut.PiHut" title="approxeng.input.pihut.PiHut"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.pihut.PiHut</span></code></a> for <a class="reference internal" href="api/pihut.html#api-pihut"><span class="std std-ref">PiHut Controller Support</span></a>.</li>
<li><a class="reference internal" href="api/spacemousepro.html#approxeng.input.spacemousepro.SpaceMousePro" title="approxeng.input.spacemousepro.SpaceMousePro"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.spacemousepro.SpaceMousePro</span></code></a> for <a class="reference internal" href="api/spacemousepro.html#api-spacemousepro"><span class="std std-ref">Wired SpaceMouse Pro Support</span></a>.</li>
</ul>
<p>In general you will not explicitly create these objects yourself, instead you can use the binding layer to discover a
connected controller (optionally supplying a particular kind of controller you want, otherwise it just finds the first
one it can). This will create the controller object from which you can read things like axis values, and also set up the
necessary logic to pull events out of the evdev linux system and update the values without you having to do anything.</p>
<p>The only time you’re likely to use these classes is to reference them when binding, this allows you to wait for a
specific kind of controller to become available - handy if, say, you really have to have a PS4 controller but you’ve
got a rock candy dongle plugged in. The details of the discovery process are at <a class="reference internal" href="api/discovery.html#discovery-reference-label"><span class="std std-ref">Controller Discovery - approxeng.input.controllers</span></a>, once
you’ve discovered the appropriate controllers you use the binding API to attach to their event streams; the details of
the binding process are described at <a class="reference internal" href="api/selectbinder.html#binding-reference-label"><span class="std std-ref">Binding - approxeng.input.selectbinder</span></a>.</p>
</div>
<div class="section" id="handling-buttons">
<h2>Handling Buttons<a class="headerlink" href="#handling-buttons" title="Permalink to this headline">¶</a></h2>
<p>There are two styles of button handler. The simplest, and the one you’re likely to use in almost all cases, is a polling
mechanism - you can ask the Controller object what buttons have been pressed since you last asked that question. This
is easy to use, you don’t have to worry you’ll miss a button press because you were off doing something else, and it
uses the standard name system. At its simplest you get back an array of standard names of buttons which were pressed
since last time. This part of the API also allows you to test for held buttons, including the duration for which the
button has been held. Handy for where you want the magnitude of a response to be determined by how long a button is held
(could be useful for simulating a ‘power charge’ or similar).</p>
<p>The second kind is to register a callback function which should be called when a button is pressed. In general you no
longer need to do this - it was used primarily for cases where e.g. a button should interrupt whatever was going on with
a robot and bounce the system back to some safe state, but there are better ways to do this. Nonetheless, this mechanism
is still present and you can use it if you really need to.</p>
<div class="section" id="handling-button-presses-as-events">
<h3>Handling Button Presses as Events<a class="headerlink" href="#handling-button-presses-as-events" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only use this method if you are absolutely sure it’s what you need. Callback functions will be called from the event
processing thread - you need to handle these extremely fast or you’ll cause issues with missed events! It’s almost
never going to be the right thing to do, you’re almost certainly better off using the polling for buttons mechanism
described in <a class="reference internal" href="simpleusage.html#poll-presses-label"><span class="std std-ref">Querying Button Presses</span></a>. With that caveat, here’s how to do it if you insist!</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">approxeng.input.selectbinder</span> <span class="kn">import</span> <span class="n">ControllerResource</span>
<span class="kn">from</span> <span class="nn">approxeng.input.dualshock3</span> <span class="kn">import</span> <span class="n">DualShock3</span>
<span class="c1"># Get a joystick</span>
<span class="k">with</span> <span class="n">ControllerResource</span><span class="p">(</span><span class="n">controller_class</span> <span class="o">=</span> <span class="n">DualShock3</span><span class="p">)</span> <span class="k">as</span> <span class="n">joystick</span><span class="p">:</span>
    <span class="c1"># Create a handler function</span>
    <span class="k">def</span> <span class="nf">button_handler</span><span class="p">(</span><span class="n">button</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Button clicked {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">button</span><span class="p">))</span>
    <span class="c1"># Register the handler to the SQUARE button</span>
    <span class="n">joystick</span><span class="o">.</span><span class="n">buttons</span><span class="o">.</span><span class="n">register_button_handler</span><span class="p">(</span><span class="n">button_handler</span><span class="p">,</span> <span class="n">joystick</span><span class="o">.</span><span class="n">buttons</span><span class="o">.</span><span class="n">for_name</span><span class="p">(</span><span class="s1">&#39;square&#39;</span><span class="p">))</span>
    <span class="c1"># We can also register a handler to multiple buttons in one call</span>
    <span class="n">joystick</span><span class="o">.</span><span class="n">buttons</span><span class="o">.</span><span class="n">register_button_handler</span><span class="p">(</span><span class="n">button_handler</span><span class="p">,</span> <span class="p">[</span><span class="n">joystick</span><span class="o">.</span><span class="n">buttons</span><span class="o">.</span><span class="n">for_name</span><span class="p">(</span><span class="s1">&#39;circle&#39;</span><span class="p">),</span>
                                                              <span class="n">joystick</span><span class="o">.</span><span class="n">buttons</span><span class="o">.</span><span class="n">for_name</span><span class="p">(</span><span class="s1">&#39;triangle&#39;</span><span class="p">)])</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Do stuff here, only register the button handlers once, not in this loop!</span>
        <span class="c1"># If the buttons are pressed, your handlers will be called but not from this thread.</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>Registering a button handler, a function which is called whenever the button is pressed, can be useful when you don’t
want to repeatedly check whether something’s been pressed. I used event handlers in Triangula’s code to jump the robot
back to her main menu any time I pressed the home button on the controller. Because I used an event to do this, I didn’t
need to worry about getting into some kind of locked state where the robot was out of control and I couldn’t stop her -
the button always did the same thing.</p>
<p>The register_button_handler function actually returns a function which can be called to de-register the handler, you
should do this to stop your handler being called when it’s no longer needed.</p>
<p>As you can see, there’s quite a lot of thinking required to make button handlers work properly. They may be the right
way to do things (for example, you might want a handler which reset the centre point of the analogue sticks, this would
be best done as a handler because it could be called at any time from anywhere else in your code and you wouldn’t have
to worry about it). If, however, you’re in a polling loop such as Triangula’s task framework or PyGame’s event loop you
probably just want to know whether a button was pressed since you last checked.</p>
</div>
</div>
<div class="section" id="more-about-analogue-axes">
<h2>More about Analogue Axes<a class="headerlink" href="#more-about-analogue-axes" title="Permalink to this headline">¶</a></h2>
<p>Analogue axes on the controller are those which can vary continuously over their range. Typically these are joysticks
and triggers. This code maps all axes either to a range from -1.0 to 1.0 (for centred axes such as joysticks) or from
0.0 to 1.0 (for things like triggers where the resting point is at one end of the range of movement). Joysticks are
modelled as two independent centred axes, one for the horizontal part and one for the vertical.</p>
<p>We could just read out the value supplied by the controller hardware and provide that value, but there are a few things
we might want to do first, and which the code provides:</p>
<ul class="simple">
<li>The centre point of the hardware is often not the numeric centre of the range. This is because hardware exists in the
real world, where things can be slightly messy. It’s generally not far off, but often the resting position isn’t at
0.0.</li>
<li>The theoretical range of the controller is often larger than the actual range produced. For example, we might have a
controller which claims to produce values from -255 to 255 (before we normalise down to -1.0 to 1.0) but which
actually only ever produces values between, say, -251 and 243.</li>
<li>It’s often desirable to have a dead zone near the resting position, so only intentional movements of the controller
are detected as motion. Analogue controls often have a bit of noise - the joystick may rest at 0 in theory, but in
practice we might see a string of values such as -1, -1, 0, 1, 1, 0, 0 etc etc.</li>
<li>Similarly, we might want a ‘hot zone’ near the extreme positions of the axis, where any higher magnitude values should
be interpreted as the maximum value. This means we’re able to get to the highest value without having to worry about
controller noise.</li>
</ul>
<p>Different controllers report different ranges (for example, the PS3 controller range is from 0 to 255 whereas the XBox
controller is from -32768 to 32768 when plugged in and, for some ungodly reason, 0 to 65335 when wireless), but you
don’t have to worry about this as the controller implementations specify this internally and you’ll only ever see values
between -1.0 and 1.0, or between 0.0 and 1.0 for trigger axes.</p>
<p>The <a class="reference internal" href="api/input.html#approxeng.input.CentredAxis" title="approxeng.input.CentredAxis"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.CentredAxis</span></code></a> and <a class="reference internal" href="api/input.html#approxeng.input.TriggerAxis" title="approxeng.input.TriggerAxis"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.TriggerAxis</span></code></a> both auto-range, in that they start
off with a maximum and minimum value that’s well within the theoretical range, and expand this out when they see higher
values from the controller. This means we don’t have to worry that the theoretical range of the controller isn’t fully
used, we’ll always have our -1.0 to 1.0 correspond to the actual controller movement.</p>
<p>Auto-centring isn’t possible as we can’t know whether the user is touching the controller, but you can set the centre
point for an individual <a class="reference internal" href="api/input.html#approxeng.input.CentredAxis" title="approxeng.input.CentredAxis"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.CentredAxis</span></code></a> by setting its ‘centre’ property, or for a complete set
defined by an <a class="reference internal" href="api/input.html#approxeng.input.Axes" title="approxeng.input.Axes"><code class="xref py py-class docutils literal notranslate"><span class="pre">approxeng.input.Axes</span></code></a> object by calling the set_axis_centres() function on the Axes object. This
function takes an arbitrary number of parameters and ignores all of them - this is done so you can specify the function
as a button handler.</p>
<p>Dead zones and hot zones are defined as a proportion of the range of the axis:</p>
<ul class="simple">
<li>For a trigger axis the dead zone is from the 0.0 raw position of the controller up to the specified value, and the hot
zone is from 1.0 - the value to 1.0. Values below the dead zone value will be returned as 0.0, and values above the
hot zone will be returned as 1.0, with values inbetween scaling from 0.0 at the edge of the dead zone to 1.0 at the
edge of the hot zone.</li>
<li>For centred axes the same applies, but with the dead zone and hot zone values specifying the proportion of each half
(positive and negative) of the range. So, if the dead zone is set to 0.1 and hot zone to 0.2, positive raw values
above 0.8 will return a corrected value of 1.0, and those below 0.1 will return 0.0. For negative values the same
applies, except that values below -0.8 will return -1.0 and those above -0.1 will return 0.0</li>
</ul>
<p>To obtain the corrected values for an axis you need to retrieve the ‘value’ property on the axis object.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sys.html" class="btn btn-neutral float-right" title="LEDs and Battery Monitoring" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="examples/tiny4wd.html" class="btn btn-neutral" title="Tiny4WD Robot Drive" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Tom Oinn
      Last updated on Feb 11, 2019.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>