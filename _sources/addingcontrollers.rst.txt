Adding support for a new controller type
========================================

The library supports a number of controllers but it's quite possible, given the variety of cheap clones on the market,
that your particular controller isn't one of them. You have a few options, depending on the scenario you find yourself
in. Firstly though you'll need both product and vendor IDs for your device - these are allocated by the USB consortium
so will definitely not be the same for a clone device as for an original one, for example.

Finding your product and vendor ID
----------------------------------

Once you have a controller paired over bluetooth, or, in the case of those with specific dongles, otherwise connected,
you can run the `scripts/list_devices.py` to print out a list of all connected devices, including the vendor and product
identifiers. For example, with my XBox One controller paired and connected I see this:

.. code-block:: bash

    (viridia-env) tom@Ogre ~/git/approxeng.input/scripts $ python list_devices.py
    { 'bus': 5,
      'fn': '/dev/input/event14',
      'name': 'Xbox Wireless Controller',
      'phys': '5c:f3:70:66:5c:e2',
      'product': 736,
      'vendor': 1118,
      'version': 2307}

In general this should show you enough information to identify the controller you've just connected and get the details.

Clones of a supported controller
--------------------------------

If you have a controller which is an exact copy of one the library supports, but isn't autodetected, you can either bind
it yourself, using the class from the library which most closely matches your controller, or you can add autodetect
support to the library, again using the existing class. This might happen if you have, say, a clone PS4 controller which
is identical in every way but which has a different USB vendor and product identifier.

The :py:const:`approxeng.input.controllers.CONTROLLERS` is an array of dicts containing class constructor, vendor ID and
product ID values. This array is searched for matching controllers when a controller class is specified, when no class
is provided this array is used to find any potential matches. If you add an appropriate entry to this array you can
cause the library's controller matching to match an existing class with a new pair of vendor and product IDs. So,
supposing you had a new controller which used the :class:`approxeng.input.dualshock4.DualShock4` codes for axes and
buttons, but had a different vendor and product ID, you could add it to the match array with:

.. code-block:: python

    import approxeng.input.controllers
    from approxeng.input.dualshock4 import DualShock4

    VENDOR_ID = ...
    PRODUCT_ID = ...

    approxeng.input.controllers.CONTROLLERS.append({'constructor': DualShock4,
                                                    'vendor_id': VENDOR_ID,
                                                    'product_id': PRODUCT_ID})

This will now let you bind using the `controller_class` or no-argument form of the resource and should match your
controller's vendor and product IDs to the existing controller class.

